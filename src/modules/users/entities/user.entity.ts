import {
  Entity,
  BaseEntity,
  Column,
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  BeforeInsert,
  OneToMany,
  ManyToOne,
  DeleteDateColumn,
  OneToOne,
} from 'typeorm';
import * as bcrypt from 'bcryptjs';
import * as crypto from 'crypto';

import { generateOTP } from '../../../common/utils/random';
import { ROLE } from '../../../common/constants/constants';
import { DeliveryAddress } from './delivery-address.entity';
import { NextOfKin } from './next-of-kin.entity';

@Entity({ name: 'users' })
export class User extends BaseEntity {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ unique: true })
  email: string;

  @Column({ default: false })
  isEmailVerified: boolean;

  @Column({ unique: true })
  phoneNumber: string;

  @Column()
  password: string;

  @Column({ default: false })
  isPasswordAutoGenerated: boolean;

  @Column({
    default:
      'https://res.cloudinary.com/aoproton/image/upload/v1592466937/ichurch/uccsobarpmaobunukx6v.png',
  })
  profileImageURL: string;

  @Column({ default: false })
  isBanned: boolean;

  @OneToMany(() => DeliveryAddress, (address) => address.user)
  deliveryAddresses: DeliveryAddress[];

  @ManyToOne(() => DeliveryAddress, { nullable: true, onDelete: 'SET NULL' })
  defaultDeliveryAddress: DeliveryAddress;

  @OneToOne(() => NextOfKin, (nextOfKin) => nextOfKin.user)
  nextOfKin: NextOfKin;

  // @Column({ type: 'jsonb', nullable: true })
  // nextOfKin: {
  //   firstName: string;
  //   lastName: string;
  //   email: string;
  //   phoneNumber: string;
  //   address: string;
  // };

  // @Column({ type: 'simple-array', nullable: true })
  // preferences: string[];

  @Column({ default: ROLE.USER })
  role: string;

  @Column({ nullable: true })
  emailVerificationToken: string;

  @Column({ type: 'timestamptz', nullable: true })
  emailVerificationTokenExpires: Date;

  @DeleteDateColumn({ type: 'timestamptz', nullable: true })
  deletedAt: Date;

  @CreateDateColumn({ type: 'timestamptz' })
  createdAt: Date;

  @UpdateDateColumn({ type: 'timestamptz' })
  updatedAt: Date;

  @BeforeInsert()
  normalizeEmail() {
    if (this.email) {
      this.email = this.email.trim().toLowerCase();
    }
  }

  // // Plain password hashing
  // @BeforeInsert()
  // @BeforeUpdate() // leads to unnecessary re-hashing of an already hashed password on every update even if the password is not modified
  // async hashPassword() {
  //   if (this.password) {
  //     const salt = await bcrypt.genSalt(10);
  //     this.password = await bcrypt.hash(this.password, salt);
  //   }
  // }

  // Password verification
  async verifyPassword(enteredPassword: string): Promise<boolean> {
    const result = await bcrypt.compare(enteredPassword, this.password);
    return result;
  }

  // Generate email verification token
  generateEmailVerificationToken(): string {
    const token = generateOTP();
    const date = new Date();
    date.setTime(date.getTime() + 10 * 60 * 1000);

    this.emailVerificationToken = crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
    this.emailVerificationTokenExpires = date;

    return token;
  }
}
