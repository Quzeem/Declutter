import * as crypto from 'crypto';
import * as bcrypt from 'bcryptjs';
import {
  BadRequestException,
  Injectable,
  Logger,
  NotFoundException,
  UnauthorizedException,
  UnprocessableEntityException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { CreateUserDto } from '../users/dto/create-user.dto';
import { UsersService } from '../users/users.service';
import { User } from '../users/entities/user.entity';
import { JwtPayload } from '../../common/interfaces/jwt-payload.interface';
import { AuthCredentialsDto, EmailDto, EmailVerificationDto } from './dto';
import { generatePassword } from '../../common/utils/random';
import { DataSource } from 'typeorm';

@Injectable()
export class AuthService {
  private logger = new Logger('AuthService');

  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private dataSource: DataSource,
  ) {}

  async signUp(createUserDto: CreateUserDto): Promise<void> {
    const { user, token } = await this.usersService.create({
      ...createUserDto,
      password: await this.hashPassword(createUserDto.password),
    });

    // Send email verification token - catch exception
    this.logger.log(
      `${user.firstName} ${user.lastName} email verification token is: ${token}`,
    );
  }

  async login(
    authCredentialsDto: AuthCredentialsDto,
  ): Promise<{ token: string; user: Partial<User> }> {
    const { email, password } = authCredentialsDto;

    const user = await this.usersService.findOneByEmail(email);

    if (!user || !(await user.verifyPassword(password))) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
    };

    const token = await this.jwtService.signAsync(payload);

    return { token, user: { id: user.id, role: user.role } };
  }

  async verifyEmail(emailVerificationDto: EmailVerificationDto) {
    const { email, token } = emailVerificationDto;

    const user = await this.usersService.findOneByEmail(email);
    if (!user) throw new NotFoundException('User not found');

    const hashedToken = crypto.createHash('sha256').update(token).digest('hex');
    if (hashedToken !== user.emailVerificationToken) {
      throw new BadRequestException('Invalid token');
    }

    if (new Date() > user.emailVerificationTokenExpires) {
      throw new BadRequestException('Token has expired');
    }

    user.isEmailVerified = true;
    user.emailVerificationToken = null;
    user.emailVerificationTokenExpires = null;
    await user.save();
  }

  async resendEmailVerificationToken(emailDto: EmailDto) {
    const { email } = emailDto;

    const user = await this.usersService.findOneByEmail(email);
    if (!user) throw new NotFoundException('User not found');

    if (user.isEmailVerified) {
      throw new BadRequestException('Your email has already been verified');
    }

    const token = user.generateEmailVerificationToken();
    await user.save();

    try {
      // Send email verification token - do not catch exception
      this.logger.log(
        `${user.firstName} ${user.lastName} email verification token is: ${token}`,
      );
    } catch (err) {
      this.logger.error(err.message);

      user.emailVerificationToken = null;
      user.emailVerificationTokenExpires = null;
      await user.save();

      throw new UnprocessableEntityException(
        'Email verification token could not be sent',
      );
    }
  }

  async resetPassword(emailDto: EmailDto) {
    const { email } = emailDto;

    const user = await this.usersService.findOneByEmail(email);
    if (!user) throw new NotFoundException('User not found');

    const password = generatePassword();

    user.password = await this.hashPassword(password);
    user.isPasswordAutoGenerated = true;

    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      await queryRunner.manager.save(user);
      // Send random generated password - do not catch exception
      this.logger.log(
        `${user.firstName} ${user.lastName} new password is: ${password}`,
      );

      await queryRunner.commitTransaction();
    } catch (err) {
      await queryRunner.rollbackTransaction();

      this.logger.error(err.message);

      throw new UnprocessableEntityException('Password reset failed');
    } finally {
      await queryRunner.release();
    }
  }

  private async hashPassword(password: string): Promise<string> {
    const salt = await bcrypt.genSalt();
    return bcrypt.hash(password, salt);
  }
}
